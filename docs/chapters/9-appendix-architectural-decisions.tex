\chapter{Anhang: Entscheidungen bei der Implementierung}

\section{Architektonische Entscheidungen}

\subsection{Wahl eines Message-Bus für das Hunt-Api Backend} \label{appendix:adr:messagebus}

\subsubsection{Kontext}

Im Rahmen der Konzeption der Backend Architektur ist zu berücksichtigen, dass das Erstellen von Schnitzeljagden und die Teilnahme an diesen zwei unterschiedlichen Domänen zuzuordnen sind. Allerdings spielen die Erstellung neuer Schnitzeljagden sowie das Bearbeiten und Entfernen bestehender Schnitzeljagden im Rahmen der Teilnahme eine wesentliche Rolle.

\subsubsection{Entscheidung}

Für die (unidirektionale) Kommunikation von dem Hunts-Service zu dem Participants-Service soll ein Message-Bus verwendet werden.

\subsubsection{Begründung}

\begin{itemize}
    \item \textbf{Validierung und Entkopplung}: Einkommende Events können mühelos von einem \textit{Event-Processor} abgefangen und gekoppelt verarbeitet werden. Durch die Verwendung eines Message-Bus wird die direkte Abhängigkeit zwischen Hunts-Service und Participants-Service minimiert. Beide Services können unabhängig voneinander weiterentwickelt und gewartet werden.
    \item \textbf{Erweiterbarkeit}: Ein Message-Bus ermöglicht es, weitere Services problemlos hinzuzufügen, die ebenfalls auf die Nachrichten des Hunts-Service reagieren können. Dies erleichtert zukünftige Erweiterungen des Systems.
    \item \textbf{Skalierbarkeit}: Der Message-Bus kann die Last verteilen und Nachrichten in einer Weise verarbeiten, die es ermöglicht, die Anzahl der Teilnehmer oder die Komplexität der Schnitzeljagden ohne Leistungseinbußen zu erhöhen.
\end{itemize}

\subsubsection{Konsequenzen}

\begin{itemize}
    \item \textbf{Operationaler Overhead}: Die Einführung und Wartung eines Message-Bus erfordert zusätzliche Infrastruktur und Überwachung, was den operativen Aufwand erhöhen kann.
    \item \textbf{Latenz}: Da die Kommunikation über einen Message-Bus asynchron erfolgt, kann es zu einer zusätzlichen Latenz kommen, bis Nachrichten verarbeitet werden.
    \item \textbf{Komplexität des Debuggings}: Das Debugging von Problemen kann komplexer werden, da die Nachrichtenverarbeitung verteilt ist und möglicherweise in mehreren Services parallel abläuft.
\end{itemize}

\subsection{Wahl eines Api-Gateways für das Hunt-Api Backend} \label{appendix:adr:proxy}

\subsubsection{Kontext}

Im Rahmen der Konzeption der Backend Architektur ist zu berücksichtigen, dass mehrere Dienste (Microservices) vorhanden sind.

\subsubsection{Entscheidung}

Über ein Api-Gateway soll die Kommunikation des Backends einheitlich erfolgen.

\subsubsection{Begründung}

Ein API-Gateway bietet eine zentrale Anlaufstelle für Anfragen an die verschiedenen Microservices. Dies vereinfacht die Verwaltung und Überwachung der Kommunikation zwischen den Diensten und den externen Clients. Durch die einheitliche Schnittstelle des API-Gateways wird die Notwendigkeit eliminiert, dass Clients direkt mit den einzelnen Microservices interagieren müssen. Dies reduziert die Komplexität auf Client-Seite und ermöglicht eine bessere Kontrolle und Sicherheit der gesamten Systemarchitektur. Außerdem kann das API-Gateway zusätzliche Funktionen wie Authentifizierung, Autorisierung und Lastverteilung bereitstellen, was die Gesamtarchitektur robuster und skalierbarer macht.

\subsubsection{Konsequenzen}

Durch die Einführung eines API-Gateways wird die Interaktion mit den Microservices zentralisiert, was die Verwaltung und Wartung des Systems erleichtert. Clients müssen nicht mehr direkt mit jedem einzelnen Dienst kommunizieren, sondern nur noch mit dem API-Gateway, was die Schnittstellenlandschaft vereinheitlicht. Darüber hinaus bietet das API-Gateway die Möglichkeit, sicherheitsspezifische Maßnahmen wie Authentifizierung und Autorisierung über spezielle Header zu implementieren. Langfristig führt dies zu einer robusteren und besser skalierbaren Systemarchitektur, die flexibler auf zukünftige Anforderungen reagieren kann.

\subsection{Hinweise und Lösungen ohne Abstrakte Klassen} \label{appendix:adr:er}

\subsubsection{Kontext}

Für das Speichern der Aufgaben (\textit{Assignments}) einer Schnitzeljagd soll es möglich sein, aus unterschiedlichen Arten von Hinweisen (\textit{Hints}) und Lösungen (\textit{Solutions}) zu wählen.

\subsubsection{Entscheidung}

Statt für jeden Hinweis-Typ und Lösungs-Typ unterschiedliche abstrakte Datenklassen zu definieren, werden diese lediglich als Daten-String gespeichert.

\subsubsection{Begründung}

Es wurde im Rahmen der Projektdurchführung versucht, mit abstrakten Datenklassen zu arbeiten. Jedoch erhöht dies die Komplexität enorm.

Zudem ist diese Lösung nicht skalierbar, denn es wird mehr Aufwand erfordert, einen neuen Hinweis-Typ oder Lösungs-Typ in das System einzubauen. Zunächst muss eine neue Datenklasse definiert werden, Dann muss diese in das Datenbank-Modell als konkrete neue Tabelle eingefügt werden.

In den meisten Fällen unterscheiden sich die Hinweis-Typen oder Lösungs-Typen kaum am Datenformat. Texte oder Bilder werden im System als String gespeichert. Daher entspringt die zentrale Frage: Wieso überhaupt mit abstrakten Klassen alles verkomplizieren?

\subsubsection{Konsequenzen}

\begin{itemize}
    \item \textbf{Keine Type-Safety}: Geo-Locations im Format \textit{lat;lon} werden als verketteter String gespeichert und müssen beim Ausleseprozess jeweils umgewandelt werden, was sehr fehleranfällig ist.
\end{itemize}

\section{Entscheidungen im Frontend}

\subsection{Wahl von Flowbite statt DaisyUI} \label{appendix:adr:daisy}

\subsubsection{Unterschied zwischen Flowbite-Svelte und DaisyUI}

\textbf{DaisyUI} ist eine Komponentenbibliothek für Tailwind CSS, die eine Vielzahl von vorgefertigten UI-Komponenten bereitstellt. Es ist darauf ausgelegt, die Nutzung von Tailwind CSS zu vereinfachen, indem es gebrauchsfertige Klassen und Designs bietet. DaisyUI ist besonders bekannt für seine einfache Integration und die Möglichkeit, schnell und effizient ästhetisch ansprechende Benutzeroberflächen zu erstellen, ohne viel eigene CSS-Regeln schreiben zu müssen. 

Im Folgenden ein Beispiel für die Verwendung von DaisyUI, um ein Modal zu erstellen:

\begin{lstlisting}[language=html, caption={Code Ausschnitt DaisyUI Beispiel}]
<button class="btn" onclick="my_modal_1.showModal()">open modal</button>
<dialog id="my_modal_1" class="modal">
  <div class="modal-box">
    <h3 class="text-lg font-bold">Hello!</h3>
    <p class="py-4">Press ESC key or click the button below to close</p>
    <div class="modal-action">
      <form method="dialog">
        <!-- if there is a button in form, it will close the modal -->
        <button class="btn">Close</button>
      </form>
    </div>
  </div>
</dialog>
\end{lstlisting}

\textbf{Flowbite-Svelte} ist eine auf Tailwind CSS basierende UI-Komponentenbibliothek, die speziell für die Integration mit Svelte entwickelt wurde. Sie bietet eine umfassende Sammlung von UI-Komponenten wie Buttons, Modale, Formulare und vieles mehr. Flowbite-Svelte kombiniert die Leistungsfähigkeit von Tailwind CSS mit der reaktiven Natur von Svelte, um die Entwicklung dynamischer und interaktiver Webanwendungen zu erleichtern. Zudem bietet Flowbite-Svelte eine nahtlose Svelte-Integration, was bedeutet, dass die Komponenten als echte Svelte-Komponenten bereitgestellt werden, die sich perfekt in das Svelte-Ökosystem einfügen. 

Im Folgenden ein Beispiel für die Verwendung von Flowbite-Svelte, das das gleiche Modal erstellt wie im DaisyUI-Beispiel:

\begin{lstlisting}[language=html, caption={Code Ausschnitt Flowbite-Svelte Beispiel}]
<script>
  import { Button, Modal } from 'flowbite-svelte';
  let defaultModal = false;
</script>

<Button on:click={() => (defaultModal = true)}>open modal</Button>
<Modal title="Hello!" bind:open={defaultModal} autoclose>
  <p class="text-base leading-relaxed text-gray-500 dark:text-gray-400">Press ESC key or click the button below to close</p>
  <svelte:fragment slot="footer">
    <Button on:click={() => (defaultModal = false)}>Close</Button>
  </svelte:fragment>
</Modal>
\end{lstlisting}

\subsubsection{Begründung für den Wechsel zu Flowbite-Svelte}

Der Wechsel von DaisyUI zu Flowbite-Svelte ist aus mehreren Gründen gerechtfertigt. Erstens bietet Flowbite-Svelte eine speziell auf Svelte abgestimmte Komponentenbibliothek, die eine engere und effizientere Integration ermöglicht. Dies bedeutet, dass die UI-Komponenten in Flowbite-Svelte als native Svelte-Komponenten verfügbar sind, was die Entwicklungsarbeit vereinfacht und die Nutzung von Svelte-spezifischen Features erleichtert.

Zweitens ist die Anpassungsfähigkeit und Erweiterbarkeit von Flowbite-Svelte ein wesentlicher Vorteil. Während DaisyUI zwar eine einfache Möglichkeit bietet, Tailwind CSS zu nutzen, ist Flowbite-Svelte besser darauf ausgelegt, komplexere und dynamischere Benutzeroberflächen zu unterstützen. Dies ist besonders wichtig für eine Anwendung wie den Schnitzeljagd-Editor, die eine hohe Interaktivität und eine benutzerfreundliche Oberfläche erfordert.

Darüber hinaus bietet Flowbite-Svelte eine breitere Palette an vorgefertigten Komponenten und Layout-Optionen, was die Entwicklung beschleunigt und gleichzeitig die Konsistenz und Qualität der Benutzeroberfläche verbessert. Dies trägt dazu bei, dass die Anwendung nicht nur funktional, sondern auch optisch ansprechend und intuitiv zu bedienen ist.